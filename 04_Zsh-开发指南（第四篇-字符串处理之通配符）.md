### 导读

这是字符串处理系列的第三篇文章。前两篇基本覆盖了字符串处理中的常用操作，但在字符串匹配方面，没有详细展开。

通配符（glob）是 shell 中的一个比较重要的概念，可以认为是正则表达式的简化版本。通配符在字符串匹配和文件名搜索等方面非常有用。本篇只讲它在字符串匹配上的用法。

### 通配符的基本用法

之前在讲字符串匹配判断时，通配符出现过，就是 `*$str*` 两边的星号。

```
% str1=abcd
% str2=bc

# 星号要在引号外边
% [[ $str1 == *$str2* ]] && echo good
good

# 注意带通配符的字符串必须放在右边
% [[ *$str2* == $str1 ]] && echo good

```

星号是最常用的通配符，用于匹配任意数量（包括 0 个）的任意字符。

```
# 问号用于匹配一个任意字符
% [[ abcd == ab?? ]] && echo good
good

# 中括号用于匹配出现在其中的单个字符
% [[ abcd == abc[bcd] ]] && echo good
good

# 如果中括号里第一个字符是 ^，则匹配除了除了中括号里的单个字符
% [[ abcd == abc[^de] ]] && echo good
% [[ abcd == abc[^ce] ]] && echo good
good

# 中括号里可以指定字符的范围
% [[ a4 == [a-b][2-5] ]] && echo good
good

# 可以指定多个字符范围，并且可以掺杂其他字符
% [[ B4 == [a-cdddA-B][2-5] ]] && echo good
good

# 尖括号用于匹配一定范围的单个整数
% [[ 123 == 12<3-4> ]] && echo good
good

# 可以匹配整个整数
% [[ 123 == <100-200> ]] && echo good
good

# 可以没有上下界，默认的下界是 0，上界是正无穷
% [[ 123 == <100-> && 123 == <-200> ]] && echo good
good

# 可以上下界都没有，那么会匹配任意正整数和 0
# 这个可以用来判断字符串是否构成整数
# [[ 123 == <-> ]] && echo good
good

# ( 1 | 2 | ... ) 用于同时判断多个条件，满足一个即可
%  [[ ab == (aa|ab) ]] && echo good
good

# 如果中括号里要用 - 或者 ^，放在最后即可，不需要转义
% [[ -^3 == [a-c-][3^-][3^-] ]] && echo good
good

```

以上是通配符的基本用法，总结一下。

| 通配符              | 含义                             |      |
| ---------------- | ------------------------------ | ---- |
| \*               | 任意数量的任意字符                      |      |
| ?                | 任意一个字符                         |      |
| [abcd]           | abcd 中的任意一个字符                  |      |
| [^abcd]          | 除 abcd 外的任意一个字符                |      |
| [a-c]            | a 和 c 之间的一个字符                  |      |
| [a-cB-Dxyz]      | a 和 c 之间、B 和 D 之间以及 xyz 中的一个字符 |      |
| <1-100>          | 1 和 100 之间的整数                  |      |
| <-50>            | 0 和 50 之间的整数                   |      |
| <100->           | 大于 100 的整数                     |      |
| <->              | 任意正整数和 0                       |      |
| ([a-c]\|<1-100>) | a 和 c 之间的一个字符或者 1 和 100 之间的整数  |      |

### 加强版通配符

Zsh 还支持加强版通配符，功能更多一些。如果使用加强版的通配符，需要先在代码里加上 `setopt EXTENDED_GLOB`。

| 通配符         | 含义                         | 匹配的样例           |
| ----------- | -------------------------- | --------------- |
| ^abc        | 除了 abc 外的任意字符串             | aaa             |
| abc^abc     | 以 abc 开头，但后边不是 abc 的字符串    | abcabd          |
| a*c~abc     | 符合 a*c 但不是 abc 的字符串        | adc             |
| a#          | 任意数量（包括 0）个 a              | aaa             |
| b##         | 一个或者多个 b                   | b               |
| (ab)##      | 一个或者多个 ab                  | abab            |
| (#i)abc     | 忽略大小写的 abc                 | AbC             |
| (#i)ab(#I)c | 忽略大小写的 ab 接着 c             | ABc             |
| (#l)aBc     | a 和 c 忽略大小写，但 B 必须大写 的 aBc | aBC             |
| (#a1)abc    | 最多错（多或缺也算）一个字符的 abc        | a2c 或 ab 或 abcd |

此外还有一些更高级的用法，暂时先略过。

### 总结

字符串的内容先告一段落，但之后的文章依然会不断地涉及字符串，因为数组和哈希表里的内容通常是字符串，处理目录文件时也涉及大量的字符串操作等等，届时会有新的字符串处理方法。此外，如果我发现新的处理字符串的方法或者技巧，也会更新这几篇文章。

### 参考

http://www.bash2zsh.com/zsh_refcard/refcard.pdf
