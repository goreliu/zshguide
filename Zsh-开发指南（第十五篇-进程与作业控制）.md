### 导读

通常情况 zsh 脚本是在一个进程中（并且单线程）执行的，但有时我们需要并行执行一些代码，因为现在的 CPU 基本都是多核的，这样可以加快运行速度。这就涉及到进程与作业控制。这里不讲进程的概念。

### 在子进程中执行代码

之前我们提到过，小括号中的代码是在子进程中执行的：

```
% (sleep 1000 && echo good)

# 然后再另一个 zsh 里查看进程
% pstree | grep sleep
     `-tmux: server-+-zsh---zsh---sleep
```

里边有两个 zsh 进程。如果不加小括号的话：

```
% sleep 1000 && echo good

# 然后再另一个 zsh 里查看进程
% pstree | grep sleep
     `-tmux: server-+-zsh---sleep
```

就只有一个 zsh 进程。这说明使用小括号时，里边的代码是在子进程（一个新的 zsh 进程）执行的。但需要注意的时，如果括号里只有一个命令（比如 sleep 1000），那么并不会再开一个子进程来执行了。

那么在子进程里执行代码有什么意义呢？如果像上边那样放着前台运行，是没有什么意义。但我们可以把它放后台运行。

### 在后台运行进程

首先我们先看下怎么把单个程序放后台运行。

```
% sleep 1000 &
[1] 850
```

在 sleep 1000 后边加一个 &，就会把它放后台运行。然后会输出一行内容，[1] 是进程的作业（job）号，850 是进程号（PID）。我们可以继续运行别的命令，不需要等待 sleep 结束了。

jobs 命令可以查看当前在后台运行的所有作业：

```
% jobs
[1]  + running    sleep 1000

# -l 会输出进程号
% jobs -l
[1]  + 850 running    sleep 1000
```

fg 命令可以把后台的作业切换回前台：

```
# 然后会继续等待 sleep 运行
% fg
[1]  + running    sleep 1000
```

如果进程已经运行起来了，我们想再把它放到后台，可以这样：

```
# 回车后按 ctrl + z
% sleep 1000
^Z
zsh: suspended  sleep 1000
# 这时可以运行 jobs 看一下，sleep 是处于挂起状态的
% jobs
[1]  + suspended  sleep 1000
# 可以用 bg 让 sleep 恢复运行
% bg
[1]  + continued  sleep 1000
# 这样 sleep 就运行在后台了
% jobs
[1]  + running    sleep 1000
```

其实 jobs、fg、bg 这些命令并不常用，大概了解下用法即可。比如现在在用 vim 编辑文件，文件还没有保存，但我想退到终端运行个命令，然后再回到 vim。可以按 ctrl + z 让 vim 挂起，然后运行命令，最后再运行 fg 让 vim 恢复。但通常我们可以启动多个终端模拟器，或者开一个新终端模拟器标签，或者用 tmux，没必要在一个 shell 里这么折腾。

### 在脚本中使用后台进程执行代码

那么回答之前的场景，要在后台进程里执行 sleep 1000 && echo good：

```
% {sleep 1000 && echo aa} &
```

这样大括号里的代码都会在后台进程里执行，脚本里可以继续写别的。如果做完了后需要再等大括号里边的代码运行。

```
#!/bin/zsh

{sleep 5 && echo p1} &
# $! 是上一个运行的后台进程的进程号
pid=$!
{sleep 10 && echo p2} &
echo aaa
# 要做的其他事情先做完
sleep 2
echo bbb
# wait 加进程号用来等待进程结束，类似 fg，但脚本中不能用 fg
wait $pid
echo ccc
```

结果：

```
% ./test.zsh
aaa
bbb
p1
ccc
# p2 是脚本运行完过几秒才输出的
% p2
```

这样我们就可以同时操作多个进程来为自己服务了。而进程之间的通信，可以用命名管道或者普通文件来做，也可以使用 socket 文件（Zsh 中有 zsh/net/socket 模块，使用它可以通过 socket 文件来通信。管道是单向的，而 socket 双向的，更灵活一些，后续我们会了解它的用法），或者使用网络通信（如果脚本分布在不同的机器，zsh 中有 zsh/net/tcp 模块，这样无需外部命令就可进行 tcp 通信，后续也会讲到它）。

### 信号

运行中的进程可以接受信号然后对信号做出响应。kill 命令用来给进程发送信号。

15（SIGTERM）是最常用的信号，也是 kill 不加参数的默认信号，用于终止一个进程。kill num 即可终止进程号是 num 的进程。但 15 信号可以被进程捕获，然后并不退出。如果要强行杀掉一个进程，可以用 9 信号（SIGKILL），它是进程无法捕获的，但这样的话进程正在做的事情会突然中断，可能会有严重的影响，所以通常情况不要使用 9 信号杀进程。

在脚本中捕获信号：

```
#!/bin/zsh

# SIGINT 是 2 信号，ctrl + c 会触发
TRAPINT() {
    # 处理一些退出前的善后工作
    sleep 333
}

sleep 1000
```

然后运行这个脚本，然后 ctrl + c，脚本没有退出，因为在执行 sleep 333，要再按一次才会退出。

在脚本中使用信号，通常是给其他进程发（主要是 15），而不是给自己发。在脚本中也很少需要捕获信号处理。信号相关的更多内容，以后可能会补充。

### 总结

本文大概讲了进程与作业控制相关内容，主要用于在脚本里使用多进程执行代码，而不是在终端里进行作业控制（因为很少需要这样做）。关于脚本中的多个进程如何配合的内容还需要继续完善。
